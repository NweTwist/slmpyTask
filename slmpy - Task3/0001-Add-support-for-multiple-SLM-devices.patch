From 684b2d87b7b77a45beb048356c3bf872c2b3e70d Mon Sep 17 00:00:00 2001
From: User <user@example.com>
Date: Sat, 14 Jun 2025 12:35:04 +0300
Subject: [PATCH] Add support for multiple SLM devices

---
 CHANGELOG              |  10 +
 LICENSE                | 520 +++++++++++++++++++++++++++++++++++++++++
 README.md              | 161 +++++++++++++
 rpi_server/SLM.desktop |   5 +
 rpi_server/install.sh  |  39 ++++
 rpi_server/server.py   |  14 ++
 setup.py               |  16 ++
 slmpy/__init__.py      |   1 +
 slmpy/slmpy.py         | 380 ++++++++++++++++++++++++++++++
 9 files changed, 1146 insertions(+)
 create mode 100644 CHANGELOG
 create mode 100644 LICENSE
 create mode 100644 README.md
 create mode 100644 rpi_server/SLM.desktop
 create mode 100644 rpi_server/install.sh
 create mode 100644 rpi_server/server.py
 create mode 100644 setup.py
 create mode 100644 slmpy/__init__.py
 create mode 100644 slmpy/slmpy.py

diff --git a/CHANGELOG b/CHANGELOG
new file mode 100644
index 0000000..49d2302
--- /dev/null
+++ b/CHANGELOG
@@ -0,0 +1,10 @@
+# Changelog
+
+## [0.2.0] 
+### Added features
+- Add setup.py for installation
+- Added `SLMdisplay.listen_port` to behave as a server that listens to a given port and wait for images to display
+- Add `Client` class to communicate from a client to a remote computer using `listen_port`
+- Add compression to send images using TCP (bz2, gzip, and zlib)
+### Bug correction
+- Corrected `SLMdisplay,close()` that made it impossible to re-initialize the SLM after closing it.
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..3414b1d
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,520 @@
+CeCILL FREE SOFTWARE LICENSE AGREEMENT
+
+Copyright (c) 2016 wavefronthsaping
+
+Version 2.1 dated 2013-06-21
+
+
+    Notice
+
+This Agreement is a Free Software license agreement that is the result
+of discussions between its authors in order to ensure compliance with
+the two main principles guiding its drafting:
+
+  * firstly, compliance with the principles governing the distribution
+    of Free Software: access to source code, broad rights granted to users,
+  * secondly, the election of a governing law, French law, with which it
+    is conformant, both as regards the law of torts and intellectual
+    property law, and the protection that it offers to both authors and
+    holders of the economic rights over software.
+
+The authors of the CeCILL (for Ce[a] C[nrs] I[nria] L[ogiciel] L[ibre]) 
+license are: 
+
+Commissariat à l'énergie atomique et aux énergies alternatives - CEA, a
+public scientific, technical and industrial research establishment,
+having its principal place of business at 25 rue Leblanc, immeuble Le
+Ponant D, 75015 Paris, France.
+
+Centre National de la Recherche Scientifique - CNRS, a public scientific
+and technological establishment, having its principal place of business
+at 3 rue Michel-Ange, 75794 Paris cedex 16, France.
+
+Institut National de Recherche en Informatique et en Automatique -
+Inria, a public scientific and technological establishment, having its
+principal place of business at Domaine de Voluceau, Rocquencourt, BP
+105, 78153 Le Chesnay cedex, France.
+
+
+    Preamble
+
+The purpose of this Free Software license agreement is to grant users
+the right to modify and redistribute the software governed by this
+license within the framework of an open source distribution model.
+
+The exercising of this right is conditional upon certain obligations for
+users so as to preserve this status for all subsequent redistributions.
+
+In consideration of access to the source code and the rights to copy,
+modify and redistribute granted by the license, users are provided only
+with a limited warranty and the software's author, the holder of the
+economic rights, and the successive licensors only have limited liability.
+
+In this respect, the risks associated with loading, using, modifying
+and/or developing or reproducing the software by the user are brought to
+the user's attention, given its Free Software status, which may make it
+complicated to use, with the result that its use is reserved for
+developers and experienced professionals having in-depth computer
+knowledge. Users are therefore encouraged to load and test the
+suitability of the software as regards their requirements in conditions
+enabling the security of their systems and/or data to be ensured and,
+more generally, to use and operate it in the same conditions of
+security. This Agreement may be freely reproduced and published,
+provided it is not altered, and that no provisions are either added or
+removed herefrom.
+
+This Agreement may apply to any or all software for which the holder of
+the economic rights decides to submit the use thereof to its provisions.
+
+Frequently asked questions can be found on the official website of the
+CeCILL licenses family (http://www.cecill.info/index.en.html) for any 
+necessary clarification.
+
+
+    Article 1 - DEFINITIONS
+
+For the purpose of this Agreement, when the following expressions
+commence with a capital letter, they shall have the following meaning:
+
+Agreement: means this license agreement, and its possible subsequent
+versions and annexes.
+
+Software: means the software in its Object Code and/or Source Code form
+and, where applicable, its documentation, "as is" when the Licensee
+accepts the Agreement.
+
+Initial Software: means the Software in its Source Code and possibly its
+Object Code form and, where applicable, its documentation, "as is" when
+it is first distributed under the terms and conditions of the Agreement.
+
+Modified Software: means the Software modified by at least one
+Contribution.
+
+Source Code: means all the Software's instructions and program lines to
+which access is required so as to modify the Software.
+
+Object Code: means the binary files originating from the compilation of
+the Source Code.
+
+Holder: means the holder(s) of the economic rights over the Initial
+Software.
+
+Licensee: means the Software user(s) having accepted the Agreement.
+
+Contributor: means a Licensee having made at least one Contribution.
+
+Licensor: means the Holder, or any other individual or legal entity, who
+distributes the Software under the Agreement.
+
+Contribution: means any or all modifications, corrections, translations,
+adaptations and/or new functions integrated into the Software by any or
+all Contributors, as well as any or all Internal Modules.
+
+Module: means a set of sources files including their documentation that
+enables supplementary functions or services in addition to those offered
+by the Software.
+
+External Module: means any or all Modules, not derived from the
+Software, so that this Module and the Software run in separate address
+spaces, with one calling the other when they are run.
+
+Internal Module: means any or all Module, connected to the Software so
+that they both execute in the same address space.
+
+GNU GPL: means the GNU General Public License version 2 or any
+subsequent version, as published by the Free Software Foundation Inc.
+
+GNU Affero GPL: means the GNU Affero General Public License version 3 or
+any subsequent version, as published by the Free Software Foundation Inc.
+
+EUPL: means the European Union Public License version 1.1 or any
+subsequent version, as published by the European Commission.
+
+Parties: mean both the Licensee and the Licensor.
+
+These expressions may be used both in singular and plural form.
+
+
+    Article 2 - PURPOSE
+
+The purpose of the Agreement is the grant by the Licensor to the
+Licensee of a non-exclusive, transferable and worldwide license for the
+Software as set forth in Article 5 <#scope> hereinafter for the whole
+term of the protection granted by the rights over said Software.
+
+
+    Article 3 - ACCEPTANCE
+
+3.1 The Licensee shall be deemed as having accepted the terms and
+conditions of this Agreement upon the occurrence of the first of the
+following events:
+
+  * (i) loading the Software by any or all means, notably, by
+    downloading from a remote server, or by loading from a physical medium;
+  * (ii) the first time the Licensee exercises any of the rights granted
+    hereunder.
+
+3.2 One copy of the Agreement, containing a notice relating to the
+characteristics of the Software, to the limited warranty, and to the
+fact that its use is restricted to experienced users has been provided
+to the Licensee prior to its acceptance as set forth in Article 3.1
+<#accepting> hereinabove, and the Licensee hereby acknowledges that it
+has read and understood it.
+
+
+    Article 4 - EFFECTIVE DATE AND TERM
+
+
+      4.1 EFFECTIVE DATE
+
+The Agreement shall become effective on the date when it is accepted by
+the Licensee as set forth in Article 3.1 <#accepting>.
+
+
+      4.2 TERM
+
+The Agreement shall remain in force for the entire legal term of
+protection of the economic rights over the Software.
+
+
+    Article 5 - SCOPE OF RIGHTS GRANTED
+
+The Licensor hereby grants to the Licensee, who accepts, the following
+rights over the Software for any or all use, and for the term of the
+Agreement, on the basis of the terms and conditions set forth hereinafter.
+
+Besides, if the Licensor owns or comes to own one or more patents
+protecting all or part of the functions of the Software or of its
+components, the Licensor undertakes not to enforce the rights granted by
+these patents against successive Licensees using, exploiting or
+modifying the Software. If these patents are transferred, the Licensor
+undertakes to have the transferees subscribe to the obligations set
+forth in this paragraph.
+
+
+      5.1 RIGHT OF USE
+
+The Licensee is authorized to use the Software, without any limitation
+as to its fields of application, with it being hereinafter specified
+that this comprises:
+
+ 1. permanent or temporary reproduction of all or part of the Software
+    by any or all means and in any or all form.
+
+ 2. loading, displaying, running, or storing the Software on any or all
+    medium.
+
+ 3. entitlement to observe, study or test its operation so as to
+    determine the ideas and principles behind any or all constituent
+    elements of said Software. This shall apply when the Licensee
+    carries out any or all loading, displaying, running, transmission or
+    storage operation as regards the Software, that it is entitled to
+    carry out hereunder.
+
+
+      5.2 ENTITLEMENT TO MAKE CONTRIBUTIONS
+
+The right to make Contributions includes the right to translate, adapt,
+arrange, or make any or all modifications to the Software, and the right
+to reproduce the resulting software.
+
+The Licensee is authorized to make any or all Contributions to the
+Software provided that it includes an explicit notice that it is the
+author of said Contribution and indicates the date of the creation thereof.
+
+
+      5.3 RIGHT OF DISTRIBUTION
+
+In particular, the right of distribution includes the right to publish,
+transmit and communicate the Software to the general public on any or
+all medium, and by any or all means, and the right to market, either in
+consideration of a fee, or free of charge, one or more copies of the
+Software by any means.
+
+The Licensee is further authorized to distribute copies of the modified
+or unmodified Software to third parties according to the terms and
+conditions set forth hereinafter.
+
+
+        5.3.1 DISTRIBUTION OF SOFTWARE WITHOUT MODIFICATION
+
+The Licensee is authorized to distribute true copies of the Software in
+Source Code or Object Code form, provided that said distribution
+complies with all the provisions of the Agreement and is accompanied by:
+
+ 1. a copy of the Agreement,
+
+ 2. a notice relating to the limitation of both the Licensor's warranty
+    and liability as set forth in Articles 8 and 9,
+
+and that, in the event that only the Object Code of the Software is
+redistributed, the Licensee allows effective access to the full Source
+Code of the Software for a period of at least three years from the
+distribution of the Software, it being understood that the additional
+acquisition cost of the Source Code shall not exceed the cost of the
+data transfer.
+
+
+        5.3.2 DISTRIBUTION OF MODIFIED SOFTWARE
+
+When the Licensee makes a Contribution to the Software, the terms and
+conditions for the distribution of the resulting Modified Software
+become subject to all the provisions of this Agreement.
+
+The Licensee is authorized to distribute the Modified Software, in
+source code or object code form, provided that said distribution
+complies with all the provisions of the Agreement and is accompanied by:
+
+ 1. a copy of the Agreement,
+
+ 2. a notice relating to the limitation of both the Licensor's warranty
+    and liability as set forth in Articles 8 and 9,
+
+and, in the event that only the object code of the Modified Software is
+redistributed,
+
+ 3. a note stating the conditions of effective access to the full source
+    code of the Modified Software for a period of at least three years
+    from the distribution of the Modified Software, it being understood
+    that the additional acquisition cost of the source code shall not
+    exceed the cost of the data transfer.
+
+
+        5.3.3 DISTRIBUTION OF EXTERNAL MODULES
+
+When the Licensee has developed an External Module, the terms and
+conditions of this Agreement do not apply to said External Module, that
+may be distributed under a separate license agreement.
+
+
+        5.3.4 COMPATIBILITY WITH OTHER LICENSES
+
+The Licensee can include a code that is subject to the provisions of one
+of the versions of the GNU GPL, GNU Affero GPL and/or EUPL in the
+Modified or unmodified Software, and distribute that entire code under
+the terms of the same version of the GNU GPL, GNU Affero GPL and/or EUPL.
+
+The Licensee can include the Modified or unmodified Software in a code
+that is subject to the provisions of one of the versions of the GNU GPL,
+GNU Affero GPL and/or EUPL and distribute that entire code under the
+terms of the same version of the GNU GPL, GNU Affero GPL and/or EUPL.
+
+
+    Article 6 - INTELLECTUAL PROPERTY
+
+
+      6.1 OVER THE INITIAL SOFTWARE
+
+The Holder owns the economic rights over the Initial Software. Any or
+all use of the Initial Software is subject to compliance with the terms
+and conditions under which the Holder has elected to distribute its work
+and no one shall be entitled to modify the terms and conditions for the
+distribution of said Initial Software.
+
+The Holder undertakes that the Initial Software will remain ruled at
+least by this Agreement, for the duration set forth in Article 4.2 <#term>.
+
+
+      6.2 OVER THE CONTRIBUTIONS
+
+The Licensee who develops a Contribution is the owner of the
+intellectual property rights over this Contribution as defined by
+applicable law.
+
+
+      6.3 OVER THE EXTERNAL MODULES
+
+The Licensee who develops an External Module is the owner of the
+intellectual property rights over this External Module as defined by
+applicable law and is free to choose the type of agreement that shall
+govern its distribution.
+
+
+      6.4 JOINT PROVISIONS
+
+The Licensee expressly undertakes:
+
+ 1. not to remove, or modify, in any manner, the intellectual property
+    notices attached to the Software;
+
+ 2. to reproduce said notices, in an identical manner, in the copies of
+    the Software modified or not.
+
+The Licensee undertakes not to directly or indirectly infringe the
+intellectual property rights on the Software of the Holder and/or
+Contributors, and to take, where applicable, vis-à-vis its staff, any
+and all measures required to ensure respect of said intellectual
+property rights of the Holder and/or Contributors.
+
+
+    Article 7 - RELATED SERVICES
+
+7.1 Under no circumstances shall the Agreement oblige the Licensor to
+provide technical assistance or maintenance services for the Software.
+
+However, the Licensor is entitled to offer this type of services. The
+terms and conditions of such technical assistance, and/or such
+maintenance, shall be set forth in a separate instrument. Only the
+Licensor offering said maintenance and/or technical assistance services
+shall incur liability therefor.
+
+7.2 Similarly, any Licensor is entitled to offer to its licensees, under
+its sole responsibility, a warranty, that shall only be binding upon
+itself, for the redistribution of the Software and/or the Modified
+Software, under terms and conditions that it is free to decide. Said
+warranty, and the financial terms and conditions of its application,
+shall be subject of a separate instrument executed between the Licensor
+and the Licensee.
+
+
+    Article 8 - LIABILITY
+
+8.1 Subject to the provisions of Article 8.2, the Licensee shall be
+entitled to claim compensation for any direct loss it may have suffered
+from the Software as a result of a fault on the part of the relevant
+Licensor, subject to providing evidence thereof.
+
+8.2 The Licensor's liability is limited to the commitments made under
+this Agreement and shall not be incurred as a result of in particular:
+(i) loss due the Licensee's total or partial failure to fulfill its
+obligations, (ii) direct or consequential loss that is suffered by the
+Licensee due to the use or performance of the Software, and (iii) more
+generally, any consequential loss. In particular the Parties expressly
+agree that any or all pecuniary or business loss (i.e. loss of data,
+loss of profits, operating loss, loss of customers or orders,
+opportunity cost, any disturbance to business activities) or any or all
+legal proceedings instituted against the Licensee by a third party,
+shall constitute consequential loss and shall not provide entitlement to
+any or all compensation from the Licensor.
+
+
+    Article 9 - WARRANTY
+
+9.1 The Licensee acknowledges that the scientific and technical
+state-of-the-art when the Software was distributed did not enable all
+possible uses to be tested and verified, nor for the presence of
+possible defects to be detected. In this respect, the Licensee's
+attention has been drawn to the risks associated with loading, using,
+modifying and/or developing and reproducing the Software which are
+reserved for experienced users.
+
+The Licensee shall be responsible for verifying, by any or all means,
+the suitability of the product for its requirements, its good working
+order, and for ensuring that it shall not cause damage to either persons
+or properties.
+
+9.2 The Licensor hereby represents, in good faith, that it is entitled
+to grant all the rights over the Software (including in particular the
+rights set forth in Article 5 <#scope>).
+
+9.3 The Licensee acknowledges that the Software is supplied "as is" by
+the Licensor without any other express or tacit warranty, other than
+that provided for in Article 9.2 <#good-faith> and, in particular,
+without any warranty as to its commercial value, its secured, safe,
+innovative or relevant nature.
+
+Specifically, the Licensor does not warrant that the Software is free
+from any error, that it will operate without interruption, that it will
+be compatible with the Licensee's own equipment and software
+configuration, nor that it will meet the Licensee's requirements.
+
+9.4 The Licensor does not either expressly or tacitly warrant that the
+Software does not infringe any third party intellectual property right
+relating to a patent, software or any other property right. Therefore,
+the Licensor disclaims any and all liability towards the Licensee
+arising out of any or all proceedings for infringement that may be
+instituted in respect of the use, modification and redistribution of the
+Software. Nevertheless, should such proceedings be instituted against
+the Licensee, the Licensor shall provide it with technical and legal
+expertise for its defense. Such technical and legal expertise shall be
+decided on a case-by-case basis between the relevant Licensor and the
+Licensee pursuant to a memorandum of understanding. The Licensor
+disclaims any and all liability as regards the Licensee's use of the
+name of the Software. No warranty is given as regards the existence of
+prior rights over the name of the Software or as regards the existence
+of a trademark.
+
+
+    Article 10 - TERMINATION
+
+10.1 In the event of a breach by the Licensee of its obligations
+hereunder, the Licensor may automatically terminate this Agreement
+thirty (30) days after notice has been sent to the Licensee and has
+remained ineffective.
+
+10.2 A Licensee whose Agreement is terminated shall no longer be
+authorized to use, modify or distribute the Software. However, any
+licenses that it may have granted prior to termination of the Agreement
+shall remain valid subject to their having been granted in compliance
+with the terms and conditions hereof.
+
+
+    Article 11 - MISCELLANEOUS
+
+
+      11.1 EXCUSABLE EVENTS
+
+Neither Party shall be liable for any or all delay, or failure to
+perform the Agreement, that may be attributable to an event of force
+majeure, an act of God or an outside cause, such as defective
+functioning or interruptions of the electricity or telecommunications
+networks, network paralysis following a virus attack, intervention by
+government authorities, natural disasters, water damage, earthquakes,
+fire, explosions, strikes and labor unrest, war, etc.
+
+11.2 Any failure by either Party, on one or more occasions, to invoke
+one or more of the provisions hereof, shall under no circumstances be
+interpreted as being a waiver by the interested Party of its right to
+invoke said provision(s) subsequently.
+
+11.3 The Agreement cancels and replaces any or all previous agreements,
+whether written or oral, between the Parties and having the same
+purpose, and constitutes the entirety of the agreement between said
+Parties concerning said purpose. No supplement or modification to the
+terms and conditions hereof shall be effective as between the Parties
+unless it is made in writing and signed by their duly authorized
+representatives.
+
+11.4 In the event that one or more of the provisions hereof were to
+conflict with a current or future applicable act or legislative text,
+said act or legislative text shall prevail, and the Parties shall make
+the necessary amendments so as to comply with said act or legislative
+text. All other provisions shall remain effective. Similarly, invalidity
+of a provision of the Agreement, for any reason whatsoever, shall not
+cause the Agreement as a whole to be invalid.
+
+
+      11.5 LANGUAGE
+
+The Agreement is drafted in both French and English and both versions
+are deemed authentic.
+
+
+    Article 12 - NEW VERSIONS OF THE AGREEMENT
+
+12.1 Any person is authorized to duplicate and distribute copies of this
+Agreement.
+
+12.2 So as to ensure coherence, the wording of this Agreement is
+protected and may only be modified by the authors of the License, who
+reserve the right to periodically publish updates or new versions of the
+Agreement, each with a separate number. These subsequent versions may
+address new issues encountered by Free Software.
+
+12.3 Any Software distributed under a given version of the Agreement may
+only be subsequently distributed under the same version of the Agreement
+or a subsequent version, subject to the provisions of Article 5.3.4
+<#compatibility>.
+
+
+    Article 13 - GOVERNING LAW AND JURISDICTION
+
+13.1 The Agreement is governed by French law. The Parties agree to
+endeavor to seek an amicable solution to any disagreements or disputes
+that may arise during the performance of the Agreement.
+
+13.2 Failing an amicable solution within two (2) months as from their
+occurrence, and unless emergency proceedings are necessary, the
+disagreements or disputes shall be referred to the Paris Courts having
+jurisdiction, by the more diligent Party.
+
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..c846480
--- /dev/null
+++ b/README.md
@@ -0,0 +1,161 @@
+# slmPy
+A simple Python module based on wxPython to interact with spatial light modulators handled as secondary monitors.
+
+## What is it for?
+
+Most Spatial Light Modulators (SLMs) are controlled via an analog (VGA) or digital (HDMI/DVI) monitor standard communication protocol. In other words, you plug it to your computer and it is recognized as a monitor display. There is usually no useful tool or API provided with the device to dynamically control the SLM. I present here a way to do this using Python.
+
+## A short explanation
+You can skip this part if you just want to get a working code, I want to briefly comment how I wrote this code and why.
+
+Displaying an image on an SLM is not harder than displaying an image on a screen. We can for example simply drag a window on the SLM "screen". However, we want to be sure to control what happen on each pixel of the SLM and avoid any interpolation that occurs when an image is resized. We then need a full screen window in which we display an image of the same resolution as the screen. My first idea was to search in the video games oriented modules, like Pygame and Pyglet. It turns out that Pygame does not support multiple screens and while Pyglet is supposed to handle them, I was only able to make it work when all the screens had the same resolution. I then searched into modules for building graphic user interfaces. Tkinter and wxPython seem to be the most popular ones. I chose wxPython, but I know it would be possible with Tkinter too.
+
+The **SLMdisplay** class of the slmpy module creates a frame (window) that is constantly refreshed in a loop. As we want to be able to send an image to display from an external code, this loop is run in a separate thread (using the Python module thread included in the standard distributions). I was largely inspired by this tutorial http://wiki.wxpython.org/MainLoopAsThread.
+
+## Requirements
+
+* A Python distribution under Linux or Windows (I did not test Mac OS, there may be issues),
+* The wxPython module available from [here](http://www.wxpython.org/),
+* An SLM with a VGA/HDMI/DVI cable.
+
+## Usage
+
+### A simple example
+First, we import the **slmpy** module
+
+```python
+import slmpy
+```
+
+We also need the numpy module, since we send the images to display as numpy arrays, and the time module.
+
+```python
+import numpy as np
+import time
+```
+
+We then create the object that handles the SLM array.
+
+```python
+slm = slmpy.SLMdisplay()
+```
+
+By default, slmpy uses the second monitor for displaying images. If you have more that one monitor in addition to the SLM, you may want to specify which monitor is the SLM.
+
+```python
+slm = slmpy.SLMdisplay(monitor = x)
+```
+
+with x the id of the SLM display as set up in the operating system. 0 correspond to the primary screen. By default, monitor is set to 1.
+
+We then retreive the size of the SLM display. These values correspond to the ones set up in you operating system, make sure they are set to the native resolution of your device. 
+
+```python
+resX, resY = slm.getSize()
+```
+
+We then generate a test image to display. Note that the image has to be converted to 8-bit integers, be careful to have integers between 0 and 255.
+
+```python
+X,Y = np.meshgrid(np.linspace(0,resX,resX),np.linspace(0,resY,resY))
+testIMG = np.round((2**8-1)*(0.5+0.5*np.sin(2*np.pi*X/50))).astype('uint8'))
+```
+
+We can then display the image on the SLM 
+
+```python
+slm.updateArray(testIMG)
+```
+
+and close the window once finished.
+
+```python
+slm.close()
+```
+ 
+
+### Image resolution and SLM resolution
+
+In the previous example we were careful to create an image with the same resolution as the SLM. Thus, one pixel of the image correspond to one pixel of the SLM. However, if one send am image of any given resolution, it will be deformed to fit the SLM array. This can be usefull when one does not need a high resolution image, for example, one can send a 400x300 image on a 800x600 screen, one pixel of the image will correspond to exactly 4 pixels of the SLM. This is faster that generating a 800x600 image with 2x2 squares of the same color as the software handles arrays 4 times smaller. However, if the image resolution is not a sub-mulitple of the SLM resolution, the interpolation could lead to dramatic effects, for example when one want to display a grating or if the SLM is DMD (binary) modulator.
+
+
+#### Image lock
+
+In SLM experiments, it is common to display images in a loop. What will happen if the image does not have the time to be displayed between two iterations of the loop? In some cases, you want to be sure that the image is displayed on the SLM using updateArray() before going further, in order to measure its physical effect for example. In some other cases, you do not want to loose sync, even if it means skipping images. You can control that with the imageLock parameter.
+
+```python
+slm = slmpy.SLMdisplay(isImageLock = True)
+```
+
+If isImageLock is set to True, the program will wait for the image to be displayed before returning from the updateArray() function. If it is set to False, it will not. By default, isImageLock is True.
+
+Check the following example with isImageLock = True or IsImageLock = False. The code sends 100 times the same blank image on the screen. We use the same image not to spend too much computational time treating the data array. You will notice that the time spent in the loop can be faster than the actual refresh rate of the monitor if isImageLock is set to False, meaning that the program will actually only send an image much less than 100 times. If isImageLock = True, the program will send exactly 100 times the image. The total time spent in the loop will then be at least 100 times the refresh time. 
+
+Note that the refresh time considered here is due to the transfer protocol, the actual response time of the liquid crystal display can be slower.  
+
+```python
+import slmpy
+import numpy as np
+import time
+slm = slmpy.SLMdisplay(isImageLock = False)
+resX, resY = slm.getSize()
+testIMG = np.zeros([resY,resX]).astype('uint8')
+t0 = time.time()
+for i in range(100):
+  slm.updateArray(testIMG)
+print time.time() - t0
+slm.close()
+```
+
+### Color layers
+
+The module can display monochromatic or color images. A standard monitor display is controlled using three 8-bit color layers (red, green and blue). For most SLMs, there is 256 or less values possible for the phase or amplitude of the pixels. The array is controlled by only one 8-bit color channel. We can then only display black and white images.
+
+However, there exists 16-bit SLMs which uses two 8-bit color channels to encode the information. For those devices, it is needed to display "color images", i.e. to control the three color layers independently (while it would still be used with a monochromatic illumination). The **updateArray()** function automatically detects if the array sent is a 2 or 3 dimensional one.
+
+Here is an example of how to show a color image. On the green layer we display sine oscillation and nothing on the other layer. If you use a secondary monitor to test, you will see green fringes.
+
+```python
+slm = slmpy.SLMdisplay(isImageLock = False)
+resX, resY = slm.getSize()
+X,Y = np.meshgrid(np.linspace(0,resX,resX),np.linspace(0,resY,resY))
+# The image we want on the green layer
+greenIMG = np.round((2**8-1)*(0.5+0.5*np.sin(2*np.pi*X/50)))
+# We need a third dimension corresponding to the color layer
+greenIMG.shape = greenIMG.shape[0], greenIMG.shape[1], 1
+# The two other layers are blank arrays
+blankImage = np.zeros([greenIMG.shape[0], greenIMG.shape[1], 1])
+# We merge the three layers in a (resY,resX,3) color array
+color_array = np.concatenate((blankImage,greenIMG,blankImage), axis=2).astype('uint8')
+# The image is sent to the slm
+slm.updateArray(color_array)
+# Wait 10 seconds
+time.sleep(10)
+# Close the window
+slm.close
+```
+
+## A dynamic example
+
+As a final example, the following code generated moving fringes. The resolution of the images is set to half the one of the SLM.
+
+```python
+import slmpy
+import time
+import numpy as np
+slm = slmpy.SLMdisplay(isImageLock = True)
+resX, resY = slm.getSize()
+# We use images twice smaller than the resolution of the slm
+ImgResX = resX//2
+ImgResY = resY//2
+X,Y = np.meshgrid(np.linspace(0,ImgResX,ImgResX),np.linspace(0,ImgResY,ImgResY))
+for i in range(100):
+  testIMG = np.round((2**8-1)*(0.5+0.5*np.sin(2*np.pi*X/50+1.0*i/10*np.pi))).astype('uint8')
+  slm.updateArray(testIMG)
+  time.sleep(0.05)
+slm.close()
+```
+
+## Other example
+
+[**python-SLM**](https://github.com/totesalaz/python-SLM), written by Luis [José Salazar-Serrano](http://www.opensourcelab.salazarserrano.com/), is good example of the use of this **slmPy** to generate the phase masks to create Laguerre Gauss beams with a SLM. 
diff --git a/rpi_server/SLM.desktop b/rpi_server/SLM.desktop
new file mode 100644
index 0000000..a96392e
--- /dev/null
+++ b/rpi_server/SLM.desktop
@@ -0,0 +1,5 @@
+[Desktop Entry]
+Encoding=UTF-8
+Name= SLM
+Exec=/usr/bin/python3.7 /home/pi/server.py
+Terminal=true
\ No newline at end of file
diff --git a/rpi_server/install.sh b/rpi_server/install.sh
new file mode 100644
index 0000000..2eb1421
--- /dev/null
+++ b/rpi_server/install.sh
@@ -0,0 +1,39 @@
+#!/usr/bin/bash
+# connect via ssn and execute these lines
+git clone https://github.com/wavefrontshaping/slmPy.git
+cd slmPy #&& bash rpi_server/install.sh
+
+# RESOLUTION="800x600"
+
+echo "Installing Python pip if not present"
+sudo apt-get install python3-pip -y
+
+# install wxPython (required for slmPy)
+# sudo apt-get install libgtk-3-dev -y
+echo "Installing wxPython dependencies"
+sudo apt install python3-wxgtk4.0 -y
+
+echo "Installing wxPython"
+sudo python3.7 -m pip install wxPython
+
+echo "Installing SlmPy"
+sudo python3.7 setup.py install 
+
+echo "Copying server script that listens to port 9999 and display the received masks on the SLM" 
+cp rpi_server/server.py /home/pi/
+
+echo "Creating a desktop file that will launch the server script on startup"
+mkdir -p /home/pi/.config/autostart
+cp rpi_server/SLM.desktop /home/pi/.config/autostart/
+
+cd ..
+
+echo "Deactivate screen blanking/sleep"
+sudo bash -c 'echo -e "\n[SeatDefaults]\nxserver-command=X -s 0 -dpms" >> /etc/lightdm/lightdm.conf'
+
+#echo "Changing resolution to "$RESOLUTION
+#export DISPLAY=:0
+#xrandr --output HDMI-1 --mode $RESOLUTION
+
+echo "Rebooting"
+sudo reboot
diff --git a/rpi_server/server.py b/rpi_server/server.py
new file mode 100644
index 0000000..0716f93
--- /dev/null
+++ b/rpi_server/server.py
@@ -0,0 +1,14 @@
+from slmpy import SLMdisplay
+import time
+
+PORT = 9999 
+
+## initialize SLM
+slm = SLMdisplay(monitor = 0, 
+                 isImageLock = True,
+                 alwaysTop = True)
+resX, resY = slm.getSize()
+print(f'Resolution: {resX}x{resY}')
+slm.listen_port(port = PORT)
+
+slm.close()
diff --git a/setup.py b/setup.py
new file mode 100644
index 0000000..9d07ed2
--- /dev/null
+++ b/setup.py
@@ -0,0 +1,16 @@
+import setuptools
+# from packagename.version import Version
+
+setuptools.setup(name='slmpy',
+                 version='0.2.0',
+                 description='Display images on a spatial light modulators.',
+                 long_description=open('README.md').read().strip(),
+                 author="Sebastien M. Popoff",
+                 author_email='sebastien.popoff@espci.psl.eu',
+                 url='https://github.com/wavefrontshaping/slmPy',
+                 py_modules=['slmpy.slmpy'],
+                 install_requires=['numpy', 'wxPython'],
+                 license='MIT License',
+                 zip_safe=False,
+                 keywords='numpy, python3, slm, wavefront shaping, display',
+                 classifiers=[''])
diff --git a/slmpy/__init__.py b/slmpy/__init__.py
new file mode 100644
index 0000000..641fa86
--- /dev/null
+++ b/slmpy/__init__.py
@@ -0,0 +1 @@
+from .slmpy import SLMdisplay, Client
\ No newline at end of file
diff --git a/slmpy/slmpy.py b/slmpy/slmpy.py
new file mode 100644
index 0000000..5951589
--- /dev/null
+++ b/slmpy/slmpy.py
@@ -0,0 +1,380 @@
+# -*- coding: utf-8 -*-
+"""
+Created on Sun Dec 06 20:14:02 2015
+
+@author: Sebastien M. Popoff
+
+"""
+
+try:
+    import wx
+except ImportError:
+    raise ImportError("The wxPython module is required to run this program.")
+import threading
+import numpy as np
+import time
+import socket
+import struct
+import bz2
+import zlib
+import gzip
+
+
+EVT_NEW_IMAGE = wx.PyEventBinder(wx.NewEventType(), 0)
+
+class ImageEvent(wx.PyCommandEvent):
+    def __init__(self, eventType=EVT_NEW_IMAGE.evtType[0], id=0):
+        wx.PyCommandEvent.__init__(self, eventType, id)
+        self.img = None
+        self.color = False
+        self.oldImageLock = None
+        self.eventLock = None
+
+
+class SLMframe(wx.Frame):
+    
+    def __init__(self, 
+                 monitor, 
+                 isImageLock,
+                 alwaysTop):
+        
+        style = wx.DEFAULT_FRAME_STYLE
+        if alwaysTop:
+            style = style | wx.STAY_ON_TOP
+        self.isImageLock = isImageLock
+        self.SetMonitor(monitor)
+        super().__init__(None,
+                         -1,
+                         'SLM window',
+                         pos = (self._x0, self._y0), 
+                         size = (self._resX, self._resY),
+                         style = style
+                        ) 
+        
+        self.Window = SLMwindow(self, 
+                                isImageLock = isImageLock,
+                                res = (self._resX, self._resY)
+                               )
+        self.Show()
+        
+        self.Bind(EVT_NEW_IMAGE, self.OnNewImage)
+        self.ShowFullScreen(not self.IsFullScreen(), wx.FULLSCREEN_ALL)
+        self.SetFocus()
+        
+    def SetMonitor(self, monitor: int):
+        if (monitor < 0 or monitor > wx.Display.GetCount()-1):
+            raise ValueError('Invalid monitor (monitor %d).' % monitor)
+        self._x0, self._y0, self._resX, self._resY = wx.Display(monitor).GetGeometry()
+        
+    def OnNewImage(self, event):
+        self.Window.UpdateImage(event)
+        
+    
+    def Quit(self):
+        wx.CallAfter(self.Destroy)
+        
+        
+class SLMwindow(wx.Window):
+    
+    def __init__(self,  *args, **kwargs):
+        self.isImageLock = kwargs.pop('isImageLock')
+        self.res = kwargs.pop('res')
+        kwargs['style'] = kwargs.setdefault('style', wx.NO_FULL_REPAINT_ON_RESIZE) | wx.NO_FULL_REPAINT_ON_RESIZE
+        super().__init__(*args, **kwargs)
+        
+        # hide cursor
+        cursor = wx.StockCursor(wx.CURSOR_BLANK)
+        self.SetCursor(cursor) 
+        
+        self.img = wx.Image(*self.res)
+        self._Buffer = wx.Bitmap(*self.res)
+        self.Bind(wx.EVT_SIZE, self.OnSize)
+        self.Bind(EVT_NEW_IMAGE, self.UpdateImage)
+        self.Bind(wx.EVT_PAINT,self.OnPaint)
+        
+        self.OnSize(None)
+        
+    def OnPaint(self, event):
+        self._Buffer = self.img.ConvertToBitmap()
+        dc = wx.BufferedPaintDC(self, self._Buffer)
+#         dc = wx.PaintDC(self)
+#         dc.DrawBitmap(self._Buffer,0,0)
+ 
+    def OnSize(self, event):
+        # The Buffer init is done here, to make sure the buffer is always
+        # the same size as the Window
+        Size = self.GetClientSize()
+
+        # Make new offscreen bitmap: this bitmap will always have the
+        # current drawing in it, so it can be used to save the image to
+        # a file, or whatever.
+        self._Buffer = wx.Bitmap(*self.res)
+        
+    def UpdateImage(self, event):
+        self.eventLock = event.eventLock
+        self.img = event.img
+        self.Refresh(eraseBackground=False)
+        
+        self.ReleaseEventLock()
+        
+    def ReleaseEventLock(self):
+        if self.eventLock:
+            if self.eventLock.locked():
+                self.eventLock.release()
+
+    
+class Client():
+    """Client class to interact with slmPy running on a distant server."""
+    def __init__(self):
+        pass
+
+    def start(self, 
+              server_address: str, 
+              port: int = 9999, 
+              compression: str = 'zlib',
+              compression_level: int = -1,
+              wait_for_reply: bool = True
+             ):
+        """
+        Parameters
+        ----------
+        server_address : str
+            Address or network name of the server to connect to.
+            Example: '192.168.0.100' / 'localhost'
+        port : int, default 9999
+            Port number of the listening socket on the server.
+        compression : str, default 'zlib'
+            Compression algorithm to use before sending the data to the client.
+            Can be 'zlib', 'gzip', 'bz2' or None for no compression.
+            If the compression is not recognized, performs no compression.
+        compression_level: int, default -1
+            Level of compression. Depends on the compression algorithm.
+        wait_for_reply: bool, default True
+            If True, wait for the server confirmation before returning when sendArray is called.
+            The server should use the argument `comfirm` in `listen_port()` with the same value.
+            Be careful, some images can be missed!
+        """
+        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+        self.client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
+        self.compression = compression
+        if compression_level == -1 and compression == 'bz2':
+            compression_level = 9
+        self.compression_level = compression_level
+        self.wait_for_reply = wait_for_reply
+        try:
+            self.client_socket.connect((server_address, port))
+            print(f'Connected to {server_address} on {port}')
+        except socket.error as e:
+            print(f'Connection to {server_address} on port {port} failed: {e}')
+            return
+
+    def _send_numpy_array(self, np_array):
+        """
+        Send a numpy array to the connected socket.
+        
+        Parameters
+        ----------
+        np_array : array_like
+            Numpy array to send to the listening socket.
+        """
+        data = np_array.tobytes()
+        
+        if self.compression == 'bz2':
+             data = bz2.compress(data, 
+                                 compresslevel = self.compression_level)
+        elif self.compression == 'zlib':
+             data = zlib.compress(data, 
+                                  level = self.compression_level)
+        elif self.compression == 'gzip':
+             data = gzip.compress(data, 
+                                  compresslevel = self.compression_level)
+
+        # Send message length first
+        # using "i" cause "L" for unsigned long does not have the same
+        # size on different systems (4 on raspberry pi!)
+        message_size = struct.pack("i", len(data)) 
+        
+
+        # Then send data
+        self.client_socket.sendall(message_size + data)
+        
+    def sendArray(self, 
+                  arr: np.ndarray, 
+                  timeout: float = 10,
+                  retries: int = 2):
+        """
+        Send a numpy array to the connected socket.
+        
+        Parameters
+        ----------
+        arr : array_like
+            Numpy array to send to the server.
+        timeout : float, default 10
+            Timeout in seconds.
+        retries : int, default 2
+            Number of times to try sending data if an error occurs.
+        """
+        if not isinstance(arr, np.ndarray):
+            print('Not a valid numpy image')
+            return
+        if not arr.dtype == np.uint8:
+            print('Numpy array should be of uint8 type')
+
+
+        for retry in range(retries):
+            self._send_numpy_array(arr)
+            t0 = time.time()
+            if retry:
+                print('Retrying')
+            if self.wait_for_reply:
+                while True:
+                    buffer = self.client_socket.recv(128)
+                    if buffer and buffer.decode() == 'done':
+                        print('Data transmitted')
+                        return 1
+                    elif buffer and buffer.decode() == 'err':
+                        print('Error. Data not transmitted')
+                        print('Wrong image size?')
+                        break
+                    elif time.time()-t0 > timeout:
+                        print('Timeout reached.')
+                        break
+            else:
+                return 1
+        else:
+            return -1
+        
+    def close(self):
+        self.client_socket.shutdown(1)
+        self.client_socket.close()
+        
+class SLMDisplay():
+    """Main class to control the SLM display."""
+    _app = None
+    _app_initialized = False
+    _instances = []
+    
+    def __init__(self,
+                 monitor = 1, 
+                 isImageLock = False,
+                 alwaysTop = False):
+        """
+        Initialize the SLM display.
+        
+        Parameters
+        ----------
+        monitor : int, default 1
+            Monitor number to use for the SLM display.
+        isImageLock : bool, default False
+            If True, the image will be locked to prevent updates while displaying.
+        alwaysTop : bool, default False
+            If True, the SLM window will always stay on top.
+        """
+        if not SLMDisplay._app_initialized:
+            SLMDisplay._app = wx.App()
+            SLMDisplay._app_initialized = True
+            
+        self.monitor = monitor
+        self.isImageLock = isImageLock
+        self.alwaysTop = alwaysTop
+        self.frame = None
+        self.videoThread = None
+        self._lock = threading.Lock()
+        
+        # Add this instance to the list of active instances
+        SLMDisplay._instances.append(self)
+        
+        # Initialize the display
+        self._init_display()
+        
+    def _init_display(self):
+        """Initialize the display window and video thread."""
+        self.frame = SLMframe(self.monitor, self.isImageLock, self.alwaysTop)
+        self.videoThread = videoThread(self)
+        self.videoThread.start()
+        
+    def updateArray(self, array, sleep = 0.2):
+        """
+        Update the displayed array.
+        
+        Parameters
+        ----------
+        array : array_like
+            Array to display.
+        sleep : float, default 0.2
+            Sleep time between updates.
+        """
+        if not isinstance(array, np.ndarray):
+            print('Not a valid numpy image')
+            return
+        if not array.dtype == np.uint8:
+            print('Numpy array should be of uint8 type')
+            return
+            
+        with self._lock:
+            if self.videoThread:
+                self.videoThread.updateImage(array)
+                time.sleep(sleep)
+                
+    def close(self):
+        """Close the SLM display and clean up resources."""
+        if self in SLMDisplay._instances:
+            SLMDisplay._instances.remove(self)
+            
+        if self.videoThread:
+            self.videoThread.stop()
+            self.videoThread = None
+            
+        if self.frame:
+            self.frame.Quit()
+            self.frame = None
+            
+        # If this was the last instance, clean up the wx app
+        if not SLMDisplay._instances and SLMDisplay._app_initialized:
+            SLMDisplay._app.Destroy()
+            SLMDisplay._app_initialized = False
+            
+    def getSize(self):
+        """Get the size of the SLM display."""
+        return self.frame._resX, self.frame._resY
+
+class videoThread(threading.Thread):
+    """Thread to handle video updates."""
+    def __init__(self, parent, autoStart=True):
+        threading.Thread.__init__(self)
+        self.parent = parent
+        self._stop_event = threading.Event()
+        self._image_lock = threading.Lock()
+        self._current_image = None
+        self._new_image_event = threading.Event()
+        
+        if autoStart:
+            self.start()
+            
+    def run(self):
+        """Main thread loop."""
+        while not self._stop_event.is_set():
+            if self._new_image_event.wait(timeout=0.1):
+                with self._image_lock:
+                    if self._current_image is not None:
+                        event = ImageEvent()
+                        event.img = wx.ImageFromBuffer(
+                            self._current_image.shape[1],
+                            self._current_image.shape[0],
+                            self._current_image.tobytes()
+                        )
+                        event.eventLock = threading.Lock()
+                        event.eventLock.acquire()
+                        wx.PostEvent(self.parent.frame, event)
+                self._new_image_event.clear()
+                
+    def updateImage(self, image):
+        """Update the current image."""
+        with self._image_lock:
+            self._current_image = image.copy()
+        self._new_image_event.set()
+        
+    def stop(self):
+        """Stop the thread."""
+        self._stop_event.set()
+        self.join()
-- 
2.39.2.windows.1

